<?php

namespace NovaTech\TestQL\Command;

use NovaTech\TestQL\Service\CurlExecutor;
use NovaTech\TestQL\Service\CurlParser;
use NovaTech\TestQL\Service\FlattenService;
use NovaTech\TestQL\Service\StubService;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\Question;
use Symfony\Component\Console\Style\SymfonyStyle;

#[AsCommand(name: 'import:test')]
class ImportTestCommand extends Command
{

    protected function configure()
    {
        $this->addOption('ignore-authentication', 'i', InputOption::VALUE_NONE, 'Ignores authentication');
        $this->addOption('namespace', 's', InputOption::VALUE_OPTIONAL, 'Namespace of the class');
        $this->addOption('name', 'm', InputOption::VALUE_REQUIRED, 'Name of the new test class');
        $this->addOption('nested-level', 'l', InputOption::VALUE_OPTIONAL, 'Level of deep object to examine');
        $this->addOption('directory', 'd', InputOption::VALUE_REQUIRED, 'Directory to save the test file');
    }

    public function readCurlStdin()
    {
        $stdin = '';

        while (!feof(STDIN)) {
            $stdin .= fread(STDIN, 1024);
        }

        return $stdin;
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $style= new SymfonyStyle($input, $output);
        $nestedLevel = $input->getOption('nested-level') ?? 3;
        $name = $input->getOption('name');
        $verbose = $input->getOption('verbose') ?? false;
        $directory = $input->getOption('directory');
        $namespace = $input->getOption('namespace') ?? null;
        $ignoreAuth = $input->getOption('ignore-authentication') ?? false;


        $curl = $this->readCurlStdin();
        $parsed = CurlParser::parse($curl);
        $executor = new CurlExecutor($parsed, $curl);
        $output = $executor->execute();
        $flatten = FlattenService::flatArray($output);
        uksort($flatten, fn($a, $b) => count(
            explode('#', $a)
        ) <=> count(explode('#', $b)));

        $examineInput = array_filter(
            $flatten,
            function ($value) use ($nestedLevel) {
                return count(explode('#', $value)) <= $nestedLevel;
            },
            ARRAY_FILTER_USE_KEY
        );

        $body = $parsed->getBody();
        $body = $body !== null && $body !== "" ? json_decode(
            $body,
            true
        ) : null;

        $stubService = new StubService();
        $stubService->initialize();
        $headers = array_map(fn($header) => is_array($header) && count($header) ? $header[0] : $header, $parsed->getHeaders());




        // if user wanted to ignore authentication
        // we will remove authorization from headers
        // if headers presents a authorization the system will automatically
        // create a AuthenticatedTestCase

        if ($ignoreAuth && isset($headers['Authorization'])) {
            unset($headers['Authorization']);
        }


        $stub = $stubService->renderTestStub(
            $name,
            (string) $parsed->getUri(),
            $parsed->getMethod(),
            $body,
            headers: $headers,
            dependencies: [],
            groups: [],
            namespace: $namespace
        );

        $filePath = implode(
            DIRECTORY_SEPARATOR,
            [
                $directory,
                $name.'.php'
            ]
        );

        file_put_contents($filePath, $stub);

        return Command::SUCCESS; // TODO: Change the autogenerated stub
    }

}